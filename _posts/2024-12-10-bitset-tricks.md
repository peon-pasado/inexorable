---
layout: post
title: Bitset tricks
subtitle: competitive programming tricks
tags: [tricks]
comments: true
mathjax: true
author: Miguel Mini
---

## Motivation

Bitset allows us to speed up bit operations, offering improvements of up to x32 or x64 depending on the judge and the compilation. However, some non-obvious ideas are useful in specific circumstances.

## Memory Tricks

__Problem 1__: Given a DAG \(G\) with \(N\) (\(1 \leq N \leq {10}^5\)) nodes and \(M\) (\(1 \leq M \leq {10}^5\)) edges, find, for each node, how many nodes can be reached through the edges in \(G\).

__Idea__: Use a bitset to determine all nodes reachable from each node. To update, simply follow the reverse order of the topological sort.


```c++
vector<bitset<maxN>> cnct(n);
for (int i=n-1; i>=0; --i) {
    int v = toposort[i];
    cnct[v][v] = 1;
    for (int u : adj[v]) {
        cnct[v] |= cnct[u];
    }
}
for (int i=0; i<n; ++i) {
    cout << cnct[i].count() << " \n"[i+1==n];
}
```

This algorithm has a time complexity of $O(N^2 / B)$, and the same memory complexity.

__Idea 2__: Memory can be optimized. Imagine we want to check if nodes in the range $\[i * B, (i + 1) * B\)$ are reachable. This can be done in $O(n + m)$.

```c++
vector<int> cnt(n);
vector<uint64_t> cnct(n);
int B = 64;
for (int l = 0; l < n; l += B) {
    int r = min(n, l + B);
    for (int i=n-1; i>=0; --i) {
        int v = toposort[i];
        cnct[v] = (l <= v && v < r) ? (1uLL << (v - l)) : 0;
        for (int u : adj[v]) {
            cnct[v] |= cnct[u];
        }
        cnt[v] += __builtin_popcountll(cnct[v]);
    }
}
for (int i=0; i<n; ++i) {
    cout << cnt[i] << " \n"[i+1==n];
}
```

Finally, we can see that the final time complexity remains the same, but the spatial complexity is $O(n + m)$.

__Problem 2__ [#158. 【清华集训2015】静态仙人掌](https://uoj.ac/problem/158): In summary, we have a rooted cactus-tree where all cycles are odd, ensuring that both the shortest and longest paths between two nodes are unique. You are tasked with the following queries; initially, all nodes are black:

1. Toggle the color of all nodes on the shortest path of $v$ from black to white and vice versa.
2. Toggle the color of all nodes on the longest path of $v$ from black to white and vice versa.
3. Count the number of black nodes in the sub cactus-tree of node $v$, defined as the maximal connected component containing $v$ after removing all edges in the shortest and longest paths.

__Idea__: The problem lies in the difficulty of grouping paths for these kinds of queries and maintaining subpaths. Therefore, a very useful idea is to maintain all paths in a bitset.

- The shortest path bitset of a node is equal to the union of its parent node’s bitset and the current node.
- The longest path is more complex but can be categorized by the types of parent edges after running a BFS. Note that if we remove all edges connecting nodes of equal distance from the root, the result is a tree.

    - If the edge does not belong to any cycle: this is analogous to the shortest path case.
    - If the parent edge was the first node discovered in the cycle: in this case, it is equal to the union of the parent’s longest path and the nodes of the cycle (there are only two nodes per cycle with this characteristic; the naive approach makes $3n$ changes).
    - In other cases, the longest path is equal to the parent’s longest path, but removing the parent node.

Note that it is possible to construct the paths by following the BFS order.

If we have the BFS tree, we can find the timestamp generated by a DFS, and we can see that a subtree can be represented as the difference between two ranges:

- The interval in the DFS.
- If it is not the last node found in a cycle, the range of the next node below the cycle in the BFS tree is removed.


```c++
for (auto u : bfs_order) {
    if (u == 1) {
        sp[u][lo[u]] = 1;
        lp[u][lo[u]] = 1;
    } else {
        sp[u] = sp[p[u]];
        sp[u][lo[u]] = 1;
        lp[u] = lp[p[u]];
        if (!in_cycle[u]) {
            lp[u][lo[u]] = 1;
        } else if (semiroot[u]) {
            for (auto v : cycl_no[u]) {
                lp[u][lo[v]] = 1;
            }
        } else {
            lp[u][lo[p[u]]] = 0;
        }
    }
}
```

The time complexity is $O(n^2 / B + 2m + qn/B)$, while the spatial complexity is $O(n^2/B)$.

__Idea 2__: We can improve spatial complexity. Since each operation reduces to 'copying' and 'assigning a position', the number of bits changed is at most $O(n + m)$. Therefore, if we maintain a persistent bitset, we can update and copy in $O(\log (n / B))$. Meanwhile, counting queries can be done in $O(n / B)$. Finally, the time complexity is $O((n + m) \log(n / B) + q (n / B))$, and the spatial complexity is $O((n + m) \log (n / B))$.

```c++
template<int N>
struct persistent_bset {

    struct Node {
        Node* l;
        Node* r;
        unsigned long long value;
    } *root;

    friend void build(Node* ro, int f, int pl = 0, int pr = (N>>6) - 1) {
        if (pl == pr) {
            ro->value = (uint64_t)-f; //0 -> 0000 | 1 -> 1111
            return;
        }
        int mid = (pl + pr) / 2;
        ro->l = new Node();
        ro->r = new Node();
        build(ro->l, f, pl, mid);
        build(ro->r, f, mid+1, pr);
    }

    friend Node* make_cpy(Node* x) {
        Node* c = new Node();
        c->l = x->l;
        c->r = x->r;
        c->value = x->value;
        return c; 
    }

    Node* update_set(int x) {
        Node* nroot = make_cpy(root);
        update(root, nroot, x);
        return nroot;
    }

    friend void update(Node* p, Node* q, int ps, int bl=0, int br=(N>>6)-1) {
        if (bl == br) {
            q->value ^= (1ull<<ps);
            assert(ps >= 0 && ps < 64);
            return;
        }
        int mi = (bl + br) / 2;
        if (ps < ((mi - bl + 1)<<6)) {
            q->l = make_cpy(p->l);
            update(p->l, q->l, ps, bl, mi);
        } else {
            q->r = make_cpy(p->r);
            update(p->r, q->r, ps - ((mi - bl + 1)<<6), mi+1, br);
        }
    }

    friend void update_inplace(Node* p, Node* q) {
        if (p->l == nullptr) {
            p->value ^= q->value;
            return;
        }
        update_inplace(p->l, q->l);
        update_inplace(p->r, q->r);
    }

    friend int count(Node* p, int l1, int r1, int l=0, int r=N-1) {
        int bl = l>>6, br = r>>6;
        if (bl == br) {
            //bl * 64, bl * 64 + 63
            int sl = l & 63, sr = (l & 63) + 63;
            int ul = l1 - (bl << 6), ur = r1 - (bl << 6);
            ul = max(sl, ul); 
            ur = min(sr, ur);
            if (ul <= ur) {
                uint64_t t = (((1ull<<(ur - ul)) - 1)<<1)|1; 
                return __builtin_popcountll((t << ul) & p->value);
            }
            return 0;
        }
        int mi = (bl + br) / 2;
        return count(p->l, l1, r1, l, (mi<<6) + 63) + count(p->r, l1, r1, (mi+1)<<6, r);
    }


    persistent_bset() {
       root = new Node();
       root->l = root->r = nullptr;
    }
};
```






